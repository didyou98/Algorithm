/*
	미로탈출 
	작성일: 2021.12.05
	작성자 : 성연재
	작성 언어 : C++
	
	문제
	동빈이는 N x M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어 이를 피해
	탈출해야 한다. 동빈이의 위치는 (1, 1)이고 미로의 출구는 (N, M)의 위치에 존재하며 한 번에 한 칸씩 
	이동할 수 있다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다. 미로는 반드시
	탈출할 수 있는 형태로 제시된다. 이때 동빈이가 탈출하기 위해 움직여야하는 최소 칸의 개수를 구하시오.
	칸을 셀 때는 시작칸과 마지막 칸을 모두 포함해서 계산한다. 
	  
	 
	입력조건
	1. 첫째 줄에 두 정수 N, M(4 <= N, M <= 200)이 주어집니다. 다음 N개의 줄에는 각각 M개의 정수 (0 혹은 1)
	로 미로의 정보가 주어진다. 각각의 수들은 공백 없이 붙어서 입력으로 제신된다. 또한 시작 칸과 마지막 칸은
	항상 1이다. 

	출력 조건 
	1. 첫째 줄에 최소 이동 칸의 개수를 출력합니다. 
	
	
	입력예시
	5 6
	101010
	111111
	000001
	111111
	111111
	
	
	
	출력예시
	10
*/

#include <bits/stdc++.h>
#define INF 1e9
using namespace std;

int n, m;
int maze[200][200];
int visited[200][200];
int result = 0;

int dx[] = {0, 0, -1, 1};
int dy[] = {-1, 1, 0, 0};

void bfs(int x, int y)
{
	queue<pair<int, int>> que;
	visited[x][y] = true;
	que.push({x, y});

	while(!que.empty())
	{
		int nx, ny = 0;
		int x = que.front().first;
		int y = que.front().second;
		que.pop();
		cout << "(" << x << "," << y << ") " << maze[x][y] <<endl;
		for(int i = 0; i < 4; i++)
		{
			nx = x + dx[i];
			ny = y + dy[i];
			if(maze[nx][ny] == 0) continue;
			if(nx < 0 || ny < 0 || nx > n || ny > m) continue;
			if(!visited[nx][ny] && maze[nx][ny] == 1)
			{
				maze[nx][ny] = maze[x][y] + 1;
				que.push({nx, ny});
				visited[nx][ny] = true;
			}
		}
	}
}

int main(void)
{
	cin >> n >> m;
	for(int i = 0; i < m; i++)
	{
		fill(maze[i], maze[i] + 1000, INF);
	}
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < m; j++)
		{
			scanf("%1d", &maze[i][j]);
		}
	}
	
	bfs(0, 0);
	
	cout << maze[n - 1][m - 1] << endl;
} 
