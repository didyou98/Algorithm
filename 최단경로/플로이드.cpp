/*
	플로이드 
	작성일: 2021.12.02
	작성 언어: C++
	작성자: 성연재
	
	문제 
	n(1 <= n <= 100)개의 도시가 있고, 한 도시에서 출발하여 다른 도시에 도착하는 m(1 <= m <= 100,000)개의
	버스가 있습니다. 각 버스는 한 번 사용할 때 필요한 비용이 있습니다. 모든 도시의 쌍(A, B)에 대해서
	도시 A에서 도시 B로 가는 데 필요한 비용의 최소값을 구하는 프로그램을 작성하시오. 
	 
	입력 조건 
	1. 첫째 줄에 도시의 개수 (1 <= n <= 100)이 주어집니다. 
	2. 둘째 줄에는 버스의 개수 (1 <= m <= 100,000)이 주어집니다. 
	3. 셋째 줄부터 m + 2줄까지 다음과 같은 버스의 정보가 주어집니다. 먼저 처음에는 그 버스의 촐발 도시의
	번호가 주어집니다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는 데 필요한 비용 c로 이루어
	져 있습니다. 시작 도시와 도착 도시가 같은 경우는 없습니다. 비용은 100,000보다 작거나 같은 자연수입니다.
	4. 시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있습니다. 
	
	출력 조건
	1. n개의 줄을 출력해야합니다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는 데 필요한 최소
	비용입니다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력합니다. 
	 
	입력 예시 
	5
	14
	1 2 2
	1 3 3
	1 4 1
	1 5 10
	2 4 2
	3 4 1
	3 5 1
	4 5 3
	3 5 10
	3 1 8
	1 4 2
	5 1 7
	3 4 2
	5 2 4
	
	
	출력 예시
	0 2 3 1 4
	12 0 15 2 5
	8 5 0 1 1
	10 7 13 0 3
	7 4 10 6 0
*/

#include <bits/stdc++.h>
#define INF 1e9

using namespace std;

int n, m;
int graph[501][501];

int main(void)
{
	cin >> n >> m;
	
	// graph 초기화 
	for(int i = 0; i < 501; i++)
	{
		fill(graph[i], graph[i] + 501, INF);
	}
	
	// 자기 자신인 경우 0 
	for(int a = 1; a <= n; a++)
	{
		for(int b = 1; b <= n; b++)
		{
			if(a == b) graph[a][b] = 0;
		}
	}
	
	// 입력값 받기 
	for(int i = 0; i < m; i++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		if(c < graph[a][b]) graph[a][b] = c;
	}
	
	// 폴로이드워샬 실행 
	for(int k = 1; k <= n; k++)
	{
		for(int a = 1; a <= n; a++)
		{
			for(int b = 1; b <= n; b++)
			{
				graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b]);
			}
		}
	}
	cout << endl;
	for (int a = 1; a <= n; a++) {
        for (int b = 1; b <= n; b++) {
            if (graph[a][b] == INF) {
                cout << "INFINITY" << ' ';
            }
            else {
                cout << graph[a][b] << ' ';
            }
        }
        cout << endl;
    }
}
